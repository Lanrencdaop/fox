package com.fox.rpc.registry;import com.fox.rpc.common.HostInfo;import com.fox.rpc.common.extension.UserServiceLoader;import com.fox.rpc.common.util.StringUtil;import com.fox.rpc.config.ConfigManager;import com.fox.rpc.config.ConfigManagerLoader;import com.fox.rpc.remoting.common.ServerInfo;import com.sun.xml.internal.bind.v2.model.core.ID;import org.apache.commons.collections4.CollectionUtils;import org.apache.commons.collections4.SetUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.*;import java.util.concurrent.ConcurrentHashMap;/** * Created by shenwenbo on 2016/10/27. */public class RegistryManager {    private static Logger LOGGER= LoggerFactory.getLogger(RegistryManager.class);    private static RegistryManager instance = new RegistryManager();    private static ConfigManager configManager = ConfigManagerLoader.getConfigManager();    private static RegistryConfigManager registryConfigManager = new DefaultRegistryConfigManager();    private static volatile boolean isInit = false;    private static ConcurrentHashMap<String, ServerInfo> referencedAddresses = new ConcurrentHashMap<String, ServerInfo>();    private volatile static List<Registry> registryList=new ArrayList<>();    private static ConcurrentHashMap<String, String> registeredServices = new ConcurrentHashMap<String, String>();    //服务对应能获取的机器    private static ConcurrentHashMap<String, Set<HostInfo>> referencedServiceAddresses = new ConcurrentHashMap<String, Set<HostInfo>>();    private static ServerInfoListener serverInfoListener=new InnerServerInfoListener();    public static RegistryManager getInstance() {        if (!isInit) {            synchronized (RegistryManager.class) {                if (!isInit) {                    instance.init(registryConfigManager.getRegistryConfig());                    RegistryEventListener.addListener(serverInfoListener);                    isInit = true;                }            }        }        return instance;    }    public static void init(Properties properties) {        List<Registry> _registryList = UserServiceLoader.getExtensionList(Registry.class);        if (_registryList.size() > 0) {            for (Registry registry : _registryList) {                registry.init(properties);                registryList.add(registry);            }        }    }    /***     * 获取服务，先从本地获取，本地获取不到时去注册中心获取；     * @param serviceName     * @return     */    public String getServiceAddress(String serviceName) {        String serviceAdress = registeredServices.get(serviceName);        if (serviceAdress!=null)            return serviceAdress;            for (Registry registry : registryList) {                serviceAdress=registry.getServiceAddress(serviceName);                registeredServices.putIfAbsent(serviceName, serviceAdress);                return serviceAdress;            }        return null;    }    public Set<HostInfo> getReferencedServiceAddresses(String serviceName) {        Set<HostInfo> hostInfos = referencedServiceAddresses.get(serviceName);        if (hostInfos == null || hostInfos.size() == 0) {            LOGGER.info("empty address list for service:" + serviceName);        }        return hostInfos;    }    public void registerService(String serviceName,String serviceAddress) {        for (Registry registry : registryList) {            registry.registerService(serviceName, serviceAddress);        }        registeredServices.putIfAbsent(serviceName, serviceAddress);        Set<HostInfo> hostInfos=null;        hostInfos=referencedServiceAddresses.get(serviceName);        // 从 RPC 服务地址中解析主机名与端口号        String[] array = StringUtil.split(serviceAddress, ":");        String host = array[0];        int port = Integer.parseInt(array[1]);        HostInfo hostInfo=new HostInfo();        hostInfo.setHost(host);        hostInfo.setPort(port);        if (CollectionUtils.isEmpty(hostInfos))            hostInfos=Collections.newSetFromMap(new ConcurrentHashMap<HostInfo, Boolean>());        hostInfos.add(hostInfo);        referencedServiceAddresses.put(serviceName,hostInfos);        LOGGER.info("service register:"+serviceAddress);    }    /**监控事件处理*/    static class InnerServerInfoListener implements ServerInfoListener{        @Override        public void onServerVersionChange(String serverAddress, String version) {            System.err.println(version);            ServerInfo serverInfo=referencedAddresses.get(serverAddress);            if (serverInfo!=null) {                serverInfo.setVersion(version);            }        }    }}